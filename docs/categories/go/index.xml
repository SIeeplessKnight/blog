<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go on SleeplessKnight's Blog</title><link>https://SIeeplessKnight.github.io/blog/categories/go/</link><description>Recent content in Go on SleeplessKnight's Blog</description><generator>Hugo -- 0.147.4</generator><language>en-us</language><lastBuildDate>Thu, 22 May 2025 11:00:00 +0000</lastBuildDate><atom:link href="https://SIeeplessKnight.github.io/blog/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency in Go is a Mouse Nest</title><link>https://SIeeplessKnight.github.io/blog/concurrency-in-go-is-a-mouse-nest/</link><pubDate>Thu, 22 May 2025 11:00:00 +0000</pubDate><guid>https://SIeeplessKnight.github.io/blog/concurrency-in-go-is-a-mouse-nest/</guid><description>&lt;h2 id="the-mouse-nest-is-the-program">The Mouse Nest is the Program&lt;/h2>
&lt;p>Imagine a mouse nest where mice cooperate for maximum productivity. Just as the nest is the central hub where all mouse activities are coordinated, in Go the program is the environment where all concurrent operations take place.&lt;/p>
&lt;h2 id="forager-and-burrow-mice-are-goroutines">Forager and Burrow Mice are Goroutines&lt;/h2>
&lt;p>Within the nest, there are forager mice who gather food, nesting materials, or other resources, and burrow mice who store and organize those resources in the nest. There are also hybrid mice who take on both roles simultaneously, however, hybrid mice aren&amp;rsquo;t as common because they can complicate coordination. In Go, these mice represent goroutines, which are lightweight threads that perform specific tasks, either sending data (like forager mice), receiving data (like burrow mice), or sending and receiving data (like hybrid mice).&lt;/p></description></item><item><title>Unsafe or Low-Level? Why Rust’s unsafe Misses the Mark</title><link>https://SIeeplessKnight.github.io/blog/unsafe-rust-misses-the-mark/</link><pubDate>Tue, 20 May 2025 11:00:00 +0000</pubDate><guid>https://SIeeplessKnight.github.io/blog/unsafe-rust-misses-the-mark/</guid><description>&lt;h2 id="the-intention-behind-unsafe">The Intention Behind &lt;code>unsafe&lt;/code>&lt;/h2>
&lt;p>Rust’s &lt;code>unsafe&lt;/code> keyword separates code its safety model can guarantee from code it can’t guarantee, but as a consequence it falsely frames low-level code as unsafe, and this has language design implications.&lt;/p>
&lt;h2 id="the-problem-with-framing-low-level-code-as-unsafe">The Problem with Framing Low-level Code as Unsafe&lt;/h2>
&lt;p>Rust&amp;rsquo;s framing of low-level code as unsafe conceptually sidelines low-level semantics, checks and tooling. It makes writing incorrect high-level code hard, but doesn&amp;rsquo;t offer the same degree of rigor for low-level code. And even for high-level code this approach feels backwards: why make writing incorrect code hard, when you can make writing correct code easy?&lt;/p></description></item></channel></rss>