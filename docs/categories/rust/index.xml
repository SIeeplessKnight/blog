<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Rust on SleeplessKnight's Blog</title><link>https://SIeeplessKnight.github.io/blog/categories/rust/</link><description>Recent content in Rust on SleeplessKnight's Blog</description><generator>Hugo -- 0.147.4</generator><language>en-us</language><lastBuildDate>Tue, 20 May 2025 11:00:00 +0000</lastBuildDate><atom:link href="https://SIeeplessKnight.github.io/blog/categories/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Unsafe or Low-Level? Why Rust’s unsafe Misses the Mark</title><link>https://SIeeplessKnight.github.io/blog/unsafe-rust-misses-the-mark/</link><pubDate>Tue, 20 May 2025 11:00:00 +0000</pubDate><guid>https://SIeeplessKnight.github.io/blog/unsafe-rust-misses-the-mark/</guid><description>&lt;h2 id="the-intention-behind-unsafe">The Intention Behind &lt;code>unsafe&lt;/code>&lt;/h2>
&lt;p>Rust’s &lt;code>unsafe&lt;/code> keyword separates code its safety model can guarantee from code it can’t guarantee, but as a consequence it falsely frames low-level code as unsafe, and this has language design implications.&lt;/p>
&lt;h2 id="the-problem-with-framing-low-level-code-as-unsafe">The Problem with Framing Low-level Code as Unsafe&lt;/h2>
&lt;p>Rust&amp;rsquo;s framing of low-level code as unsafe conceptually sidelines low-level semantics, checks and tooling. It makes writing incorrect high-level code hard, but doesn&amp;rsquo;t offer the same degree of rigor for low-level code. And even for high-level code this approach feels backwards: why make writing incorrect code hard, when you can make writing correct code easy?&lt;/p></description></item></channel></rss>